import codecs
from twisted.internet import protocol
from twisted.mail._cred import CramMD5ClientAuthenticator as CramMD5ClientAuthenticator, LOGINAuthenticator as LOGINAuthenticator, LOGINCredentials as _lcredentials
from twisted.mail._except import AUTHDeclinedError as AUTHDeclinedError, AUTHRequiredError as AUTHRequiredError, AddressError as AddressError, AuthenticationError as AuthenticationError, EHLORequiredError as EHLORequiredError, ESMTPClientError as ESMTPClientError, SMTPAddressError as SMTPAddressError, SMTPBadRcpt as SMTPBadRcpt, SMTPBadSender as SMTPBadSender, SMTPClientError as SMTPClientError, SMTPConnectError as SMTPConnectError, SMTPDeliveryError as SMTPDeliveryError, SMTPError as SMTPError, SMTPProtocolError as SMTPProtocolError, SMTPServerError as SMTPServerError, SMTPTLSError as TLSError, SMTPTimeoutError as SMTPTimeoutError, TLSRequiredError as TLSRequiredError
from twisted.mail.interfaces import IClientAuthentication as IClientAuthentication, IMessageDelivery as IMessageDelivery, IMessageDeliveryFactory as IMessageDeliveryFactory, IMessageSMTP as IMessage
from twisted.protocols import basic, policies
from typing import Any, Optional

def rfc822date(timeinfo: Optional[Any] = ..., local: int = ...): ...
def idGenerator() -> None: ...
def messageid(uniq: Optional[Any] = ..., N: Any = ...): ...
def quoteaddr(addr: Any): ...

class Address:
    tstring: Any = ...
    atomre: Any = ...
    __dict__: Any = ...
    addrstr: Any = ...
    local: Any = ...
    domain: Any = ...
    def __init__(self, addr: Any, defaultDomain: Optional[Any] = ...) -> None: ...
    dequotebs: Any = ...
    def dequote(self, addr: Any): ...
    def __bytes__(self): ...

class User:
    dest: Any = ...
    helo: Any = ...
    protocol: Any = ...
    orig: Any = ...
    def __init__(self, destination: Any, helo: Any, protocol: Any, orig: Any) -> None: ...
    def __bytes__(self): ...

class SMTP(basic.LineOnlyReceiver, policies.TimeoutMixin):
    timeout: int = ...
    portal: Any = ...
    noisy: bool = ...
    deliveryFactory: Any = ...
    delivery: Any = ...
    mode: Any = ...
    def __init__(self, delivery: Optional[Any] = ..., deliveryFactory: Optional[Any] = ...) -> None: ...
    @property
    def host(self): ...
    @host.setter
    def host(self, toSet: Any) -> None: ...
    def timeoutConnection(self) -> None: ...
    def greeting(self): ...
    def connectionMade(self) -> None: ...
    def sendCode(self, code: Any, message: bytes = ...) -> None: ...
    def lineReceived(self, line: Any): ...
    def state_COMMAND(self, line: Any) -> None: ...
    def sendSyntaxError(self) -> None: ...
    def lookupMethod(self, command: Any): ...
    def lineLengthExceeded(self, line: Any) -> None: ...
    def do_UNKNOWN(self, rest: Any) -> None: ...
    def do_HELO(self, rest: Any) -> None: ...
    def do_QUIT(self, rest: Any) -> None: ...
    qstring: Any = ...
    mail_re: Any = ...
    rcpt_re: Any = ...
    def do_MAIL(self, rest: Any) -> None: ...
    def do_RCPT(self, rest: Any) -> None: ...
    datafailed: Any = ...
    def do_DATA(self, rest: Any) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...
    def do_RSET(self, rest: Any) -> None: ...
    def dataLineReceived(self, line: Any) -> None: ...
    state_DATA: Any = ...
    def validateFrom(self, helo: Any, origin: Any): ...
    def validateTo(self, user: Any): ...
    def receivedHeader(self, helo: Any, origin: Any, recipients: Any): ...

class SMTPFactory(protocol.ServerFactory):
    domain: Any = ...
    timeout: int = ...
    protocol: Any = ...
    portal: Any = ...
    def __init__(self, portal: Optional[Any] = ...) -> None: ...
    def buildProtocol(self, addr: Any): ...

class SMTPClient(basic.LineReceiver, policies.TimeoutMixin):
    debug: bool = ...
    timeout: Any = ...
    identity: Any = ...
    toAddressesResult: Any = ...
    successAddresses: Any = ...
    resp: Any = ...
    code: int = ...
    log: Any = ...
    def __init__(self, identity: Any, logsize: int = ...) -> None: ...
    def sendLine(self, line: Any) -> None: ...
    def connectionMade(self) -> None: ...
    mailFile: Any = ...
    def connectionLost(self, reason: Any = ...) -> None: ...
    def timeoutConnection(self) -> None: ...
    def lineReceived(self, line: Any): ...
    def smtpConnectionFailed(self, code: Any, resp: Any) -> None: ...
    def smtpTransferFailed(self, code: Any, resp: Any) -> None: ...
    def smtpState_helo(self, code: Any, resp: Any) -> None: ...
    def smtpState_from(self, code: Any, resp: Any) -> None: ...
    def smtpState_disconnect(self, code: Any, resp: Any) -> None: ...
    toAddresses: Any = ...
    lastAddress: Any = ...
    def smtpState_to(self, code: Any, resp: Any): ...
    def smtpState_toOrData(self, code: Any, resp: Any): ...
    def smtpState_data(self, code: Any, resp: Any) -> None: ...
    def smtpState_msgSent(self, code: Any, resp: Any) -> None: ...
    def transformChunk(self, chunk: Any): ...
    def finishedFileTransfer(self, lastsent: Any) -> None: ...
    def getMailFrom(self) -> None: ...
    def getMailTo(self) -> None: ...
    def getMailData(self) -> None: ...
    def sendError(self, exc: Any) -> None: ...
    def sentMail(self, code: Any, resp: Any, numOk: Any, addresses: Any, log: Any) -> None: ...

class ESMTPClient(SMTPClient):
    heloFallback: bool = ...
    requireAuthentication: bool = ...
    requireTransportSecurity: bool = ...
    context: Any = ...
    authenticators: Any = ...
    secret: Any = ...
    def __init__(self, secret: Any, contextFactory: Optional[Any] = ..., *args: Any, **kw: Any) -> None: ...
    def __getattr__(self, name: Any): ...
    def __setattr__(self, name: Any, value: Any) -> None: ...
    def esmtpEHLORequired(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpAUTHRequired(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpTLSRequired(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpTLSFailed(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpAUTHDeclined(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpAUTHMalformedChallenge(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def esmtpAUTHServerError(self, code: int = ..., resp: Optional[Any] = ...) -> None: ...
    def registerAuthenticator(self, auth: Any) -> None: ...
    def connectionMade(self) -> None: ...
    def esmtpState_ehlo(self, code: Any, resp: Any) -> None: ...
    def esmtpState_serverConfig(self, code: Any, resp: Any) -> None: ...
    def tryTLS(self, code: Any, resp: Any, items: Any) -> None: ...
    def esmtpState_starttls(self, code: Any, resp: Any) -> None: ...
    def authenticate(self, code: Any, resp: Any, items: Any) -> None: ...
    def esmtpState_challenge(self, code: Any, resp: Any) -> None: ...
    def smtpState_maybeAuthenticated(self, code: Any, resp: Any) -> None: ...

class ESMTP(SMTP):
    ctx: Any = ...
    canStartTLS: bool = ...
    startedTLS: bool = ...
    authenticated: bool = ...
    challengers: Any = ...
    def __init__(self, chal: Optional[Any] = ..., contextFactory: Optional[Any] = ...) -> None: ...
    def connectionMade(self) -> None: ...
    def greeting(self): ...
    def extensions(self): ...
    def lookupMethod(self, command: Any): ...
    def listExtensions(self): ...
    def do_EHLO(self, rest: Any) -> None: ...
    def ext_STARTTLS(self, rest: Any) -> None: ...
    mode: Any = ...
    challenger: Any = ...
    def ext_AUTH(self, rest: Any) -> None: ...
    def state_AUTH(self, response: Any): ...

class SenderMixin:
    done: int = ...
    def getMailFrom(self): ...
    def getMailTo(self): ...
    def getMailData(self): ...
    def sendError(self, exc: Any) -> None: ...
    def sentMail(self, code: Any, resp: Any, numOk: Any, addresses: Any, log: Any) -> None: ...

class SMTPSender(SenderMixin, SMTPClient): ...

class SMTPSenderFactory(protocol.ClientFactory):
    domain: Any = ...
    protocol: Any = ...
    fromEmail: Any = ...
    nEmails: Any = ...
    toEmail: Any = ...
    file: Any = ...
    result: Any = ...
    sendFinished: bool = ...
    currentProtocol: Any = ...
    retries: Any = ...
    timeout: Any = ...
    def __init__(self, fromEmail: Any, toEmail: Any, file: Any, deferred: Any, retries: int = ..., timeout: Optional[Any] = ...) -> None: ...
    def clientConnectionFailed(self, connector: Any, err: Any) -> None: ...
    def clientConnectionLost(self, connector: Any, err: Any) -> None: ...
    def buildProtocol(self, addr: Any): ...

class LOGINCredentials(_lcredentials):
    challenges: Any = ...
    def __init__(self) -> None: ...

class PLAINAuthenticator:
    user: Any = ...
    def __init__(self, user: Any) -> None: ...
    def getName(self): ...
    def challengeResponse(self, secret: Any, chal: int = ...): ...

class ESMTPSender(SenderMixin, ESMTPClient):
    requireAuthentication: bool = ...
    requireTransportSecurity: bool = ...
    heloFallback: int = ...
    username: Any = ...
    def __init__(self, username: Any, secret: Any, contextFactory: Optional[Any] = ..., *args: Any, **kw: Any) -> None: ...

class ESMTPSenderFactory(SMTPSenderFactory):
    protocol: Any = ...
    username: Any = ...
    password: Any = ...
    def __init__(self, username: Any, password: Any, fromEmail: Any, toEmail: Any, file: Any, deferred: Any, retries: int = ..., timeout: Optional[Any] = ..., contextFactory: Optional[Any] = ..., heloFallback: bool = ..., requireAuthentication: bool = ..., requireTransportSecurity: bool = ...) -> None: ...
    currentProtocol: Any = ...
    def buildProtocol(self, addr: Any): ...

def sendmail(smtphost: Any, from_addr: Any, to_addrs: Any, msg: Any, senderDomainName: Optional[Any] = ..., port: int = ..., reactor: Any = ..., username: Optional[Any] = ..., password: Optional[Any] = ..., requireAuthentication: bool = ..., requireTransportSecurity: bool = ...): ...
def xtext_encode(s: Any, errors: Optional[Any] = ...): ...
def xtext_decode(s: Any, errors: Optional[Any] = ...): ...

class xtextStreamReader(codecs.StreamReader):
    def decode(self, s: Any, errors: str = ...): ...

class xtextStreamWriter(codecs.StreamWriter):
    def decode(self, s: Any, errors: str = ...): ...

def xtext_codec(name: Any): ...
