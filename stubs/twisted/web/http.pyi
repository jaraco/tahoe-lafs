from twisted.internet import protocol
from twisted.protocols import basic, policies
from twisted.web._responses import ACCEPTED as ACCEPTED, BAD_GATEWAY as BAD_GATEWAY, BAD_REQUEST as BAD_REQUEST, CONFLICT as CONFLICT, CREATED as CREATED, EXPECTATION_FAILED as EXPECTATION_FAILED, FORBIDDEN as FORBIDDEN, FOUND as FOUND, GATEWAY_TIMEOUT as GATEWAY_TIMEOUT, GONE as GONE, HTTP_VERSION_NOT_SUPPORTED as HTTP_VERSION_NOT_SUPPORTED, INSUFFICIENT_STORAGE_SPACE as INSUFFICIENT_STORAGE_SPACE, INTERNAL_SERVER_ERROR as INTERNAL_SERVER_ERROR, LENGTH_REQUIRED as LENGTH_REQUIRED, MOVED_PERMANENTLY as MOVED_PERMANENTLY, MULTIPLE_CHOICE as MULTIPLE_CHOICE, MULTI_STATUS as MULTI_STATUS, NON_AUTHORITATIVE_INFORMATION as NON_AUTHORITATIVE_INFORMATION, NOT_ACCEPTABLE as NOT_ACCEPTABLE, NOT_ALLOWED as NOT_ALLOWED, NOT_EXTENDED as NOT_EXTENDED, NOT_FOUND as NOT_FOUND, NOT_IMPLEMENTED as NOT_IMPLEMENTED, NOT_MODIFIED as NOT_MODIFIED, NO_CONTENT as NO_CONTENT, OK as OK, PARTIAL_CONTENT as PARTIAL_CONTENT, PAYMENT_REQUIRED as PAYMENT_REQUIRED, PERMANENT_REDIRECT as PERMANENT_REDIRECT, PRECONDITION_FAILED as PRECONDITION_FAILED, PROXY_AUTH_REQUIRED as PROXY_AUTH_REQUIRED, REQUESTED_RANGE_NOT_SATISFIABLE as REQUESTED_RANGE_NOT_SATISFIABLE, REQUEST_ENTITY_TOO_LARGE as REQUEST_ENTITY_TOO_LARGE, REQUEST_TIMEOUT as REQUEST_TIMEOUT, REQUEST_URI_TOO_LONG as REQUEST_URI_TOO_LONG, RESET_CONTENT as RESET_CONTENT, RESPONSES as RESPONSES, SEE_OTHER as SEE_OTHER, SERVICE_UNAVAILABLE as SERVICE_UNAVAILABLE, SWITCHING as SWITCHING, TEMPORARY_REDIRECT as TEMPORARY_REDIRECT, UNAUTHORIZED as UNAUTHORIZED, UNSUPPORTED_MEDIA_TYPE as UNSUPPORTED_MEDIA_TYPE, USE_PROXY as USE_PROXY
from typing import Any, Optional
from zope.interface import Interface

CACHED: str
responses = RESPONSES

def urlparse(url: Any): ...
def parse_qs(qs: Any, keep_blank_values: int = ..., strict_parsing: int = ...): ...
def datetimeToString(msSinceEpoch: Optional[Any] = ...): ...
def datetimeToLogString(msSinceEpoch: Optional[Any] = ...): ...
def timegm(year: Any, month: Any, day: Any, hour: Any, minute: Any, second: Any): ...
def stringToDatetime(dateString: Any): ...
def toChunk(data: Any): ...
def fromChunk(data: Any): ...
def parseContentRange(header: Any): ...

class _IDeprecatedHTTPChannelToRequestInterface(Interface):
    requestHeaders: Any = ...
    responseHeaders: Any = ...
    def connectionLost(reason: Any) -> None: ...
    def gotLength(length: Any) -> None: ...
    def handleContentChunk(data: Any) -> None: ...
    def parseCookies() -> None: ...
    def requestReceived(command: Any, path: Any, version: Any) -> None: ...
    def __eq__(other: object) -> bool: ...
    def __ne__(other: object) -> bool: ...
    def __hash__() -> Any: ...

class StringTransport:
    s: Any = ...
    def __init__(self) -> None: ...
    def writeSequence(self, seq: Any) -> None: ...
    def __getattr__(self, attr: Any): ...

class HTTPClient(basic.LineReceiver):
    length: Any = ...
    firstLine: bool = ...
    def sendCommand(self, command: Any, path: Any) -> None: ...
    def sendHeader(self, name: Any, value: Any) -> None: ...
    def endHeaders(self) -> None: ...
    def extractHeader(self, header: Any) -> None: ...
    def lineReceived(self, line: Any) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...
    def handleResponseEnd(self) -> None: ...
    def handleResponsePart(self, data: Any) -> None: ...
    def connectionMade(self) -> None: ...
    def handleStatus(self, version: Any, status: Any, message: Any) -> None: ...
    def handleHeader(self, key: Any, val: Any) -> None: ...
    def handleEndHeaders(self) -> None: ...
    def rawDataReceived(self, data: Any) -> None: ...

NO_BODY_CODES: Any

class Request:
    producer: Any = ...
    finished: int = ...
    code: Any = ...
    code_message: Any = ...
    method: bytes = ...
    clientproto: bytes = ...
    uri: str = ...
    startedWriting: int = ...
    chunked: int = ...
    sentLength: int = ...
    etag: Any = ...
    lastModified: Any = ...
    args: Any = ...
    path: Any = ...
    content: Any = ...
    notifications: Any = ...
    channel: Any = ...
    client: Any = ...
    host: Any = ...
    requestHeaders: Any = ...
    received_cookies: Any = ...
    responseHeaders: Any = ...
    cookies: Any = ...
    transport: Any = ...
    queued: Any = ...
    def __init__(self, channel: Any, queued: Any = ...) -> None: ...
    def noLongerQueued(self) -> None: ...
    def gotLength(self, length: Any) -> None: ...
    def parseCookies(self) -> None: ...
    def handleContentChunk(self, data: Any) -> None: ...
    def requestReceived(self, command: Any, path: Any, version: Any) -> None: ...
    def process(self) -> None: ...
    streamingProducer: Any = ...
    def registerProducer(self, producer: Any, streaming: Any) -> None: ...
    def unregisterProducer(self) -> None: ...
    def getHeader(self, key: Any): ...
    def getCookie(self, key: Any): ...
    def notifyFinish(self): ...
    def finish(self) -> None: ...
    def write(self, data: Any) -> None: ...
    def addCookie(self, k: Any, v: Any, expires: Optional[Any] = ..., domain: Optional[Any] = ..., path: Optional[Any] = ..., max_age: Optional[Any] = ..., comment: Optional[Any] = ..., secure: Optional[Any] = ..., httpOnly: bool = ..., sameSite: Optional[Any] = ...): ...
    def setResponseCode(self, code: Any, message: Optional[Any] = ...) -> None: ...
    def setHeader(self, name: Any, value: Any) -> None: ...
    def redirect(self, url: Any) -> None: ...
    def setLastModified(self, when: Any): ...
    def setETag(self, etag: Any): ...
    def getAllHeaders(self): ...
    def getRequestHostname(self): ...
    def getHost(self): ...
    def setHost(self, host: Any, port: Any, ssl: int = ...) -> None: ...
    def getClientIP(self): ...
    def getClientAddress(self): ...
    def isSecure(self): ...
    def getUser(self): ...
    def getPassword(self): ...
    def connectionLost(self, reason: Any) -> None: ...
    def loseConnection(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> Any: ...

class _DataLoss(Exception): ...
class PotentialDataLoss(Exception): ...
class _MalformedChunkedDataError(Exception): ...

class _IdentityTransferDecoder:
    contentLength: Any = ...
    dataCallback: Any = ...
    finishCallback: Any = ...
    def __init__(self, contentLength: Any, dataCallback: Any, finishCallback: Any) -> None: ...
    def dataReceived(self, data: Any) -> None: ...
    def noMoreData(self) -> None: ...

class _ChunkedTransferDecoder:
    state: str = ...
    dataCallback: Any = ...
    finishCallback: Any = ...
    def __init__(self, dataCallback: Any, finishCallback: Any) -> None: ...
    def dataReceived(self, data: Any) -> None: ...
    def noMoreData(self) -> None: ...

class _NoPushProducer:
    def pauseProducing(self) -> None: ...
    def resumeProducing(self) -> None: ...
    def registerProducer(self, producer: Any, streaming: Any) -> None: ...
    def unregisterProducer(self) -> None: ...
    def stopProducing(self) -> None: ...

class HTTPChannel(basic.LineReceiver, policies.TimeoutMixin):
    maxHeaders: int = ...
    totalHeadersSize: int = ...
    abortTimeout: int = ...
    length: int = ...
    persistent: int = ...
    requestFactory: Any = ...
    requests: Any = ...
    def __init__(self) -> None: ...
    def connectionMade(self) -> None: ...
    def lineReceived(self, line: Any) -> None: ...
    def headerReceived(self, line: Any): ...
    def allContentReceived(self) -> None: ...
    def dataReceived(self, data: Any): ...
    def rawDataReceived(self, data: Any) -> None: ...
    def allHeadersReceived(self) -> None: ...
    def checkPersistence(self, request: Any, version: Any): ...
    def requestDone(self, request: Any) -> None: ...
    def timeoutConnection(self) -> None: ...
    def forceAbortClient(self) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...
    def isSecure(self): ...
    def writeHeaders(self, version: Any, code: Any, reason: Any, headers: Any) -> None: ...
    def write(self, data: Any) -> None: ...
    def writeSequence(self, iovec: Any) -> None: ...
    def getPeer(self): ...
    def getHost(self): ...
    def loseConnection(self): ...
    def registerProducer(self, producer: Any, streaming: Any) -> None: ...
    def unregisterProducer(self) -> None: ...
    def stopProducing(self) -> None: ...
    def pauseProducing(self) -> None: ...
    def resumeProducing(self) -> None: ...

class _XForwardedForAddress:
    host: Any = ...
    def __init__(self, host: Any) -> None: ...

class _XForwardedForRequest:
    def getClientAddress(self): ...
    @property
    def clientproto(self): ...
    @property
    def code(self): ...
    @property
    def sentLength(self): ...

class _GenericHTTPChannelProtocol:
    @property
    def factory(self): ...
    @factory.setter
    def factory(self, value: Any) -> None: ...
    @property
    def requestFactory(self): ...
    @requestFactory.setter
    def requestFactory(self, value: Any) -> None: ...
    @property
    def site(self): ...
    @site.setter
    def site(self, value: Any) -> None: ...
    @property
    def timeOut(self): ...
    @timeOut.setter
    def timeOut(self, value: Any) -> None: ...
    @property
    def callLater(self): ...
    @callLater.setter
    def callLater(self, value: Any) -> None: ...
    def dataReceived(self, data: Any): ...

class HTTPFactory(protocol.ServerFactory):
    protocol: Any = ...
    logPath: Any = ...
    timeOut: Any = ...
    def __init__(self, logPath: Optional[Any] = ..., timeout: Any = ..., logFormatter: Optional[Any] = ..., reactor: Optional[Any] = ...) -> None: ...
    def buildProtocol(self, addr: Any): ...
    logFile: Any = ...
    def startFactory(self) -> None: ...
    def stopFactory(self) -> None: ...
    def log(self, request: Any) -> None: ...
