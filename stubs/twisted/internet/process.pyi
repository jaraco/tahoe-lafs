from twisted.internet import abstract as abstract, error as error, fdesc as fdesc
from twisted.internet._baseprocess import BaseProcess as BaseProcess
from twisted.internet.interfaces import IProcessTransport as IProcessTransport
from twisted.internet.main import CONNECTION_DONE as CONNECTION_DONE, CONNECTION_LOST as CONNECTION_LOST
from twisted.python import failure as failure, log as log
from twisted.python.runtime import platform as platform
from twisted.python.util import switchUID as switchUID
from typing import Any, Callable, Dict, Optional

pty: Any
fcntl: Any
ProcessExitedAlready = error.ProcessExitedAlready
reapProcessHandlers: Dict[int, Callable]

def reapAllProcesses() -> None: ...
def registerReapProcessHandler(pid: Any, process: Any) -> None: ...
def unregisterReapProcessHandler(pid: Any, process: Any) -> None: ...

class ProcessWriter(abstract.FileDescriptor):
    connected: int = ...
    ic: int = ...
    enableReadHack: bool = ...
    proc: Any = ...
    name: Any = ...
    fd: Any = ...
    def __init__(self, reactor: Any, proc: Any, name: Any, fileno: Any, forceReadHack: bool = ...) -> None: ...
    def fileno(self): ...
    def writeSomeData(self, data: Any): ...
    def write(self, data: Any) -> None: ...
    def doRead(self): ...
    def connectionLost(self, reason: Any) -> None: ...

class ProcessReader(abstract.FileDescriptor):
    connected: bool = ...
    proc: Any = ...
    name: Any = ...
    fd: Any = ...
    def __init__(self, reactor: Any, proc: Any, name: Any, fileno: Any) -> None: ...
    def fileno(self): ...
    def writeSomeData(self, data: Any): ...
    def doRead(self): ...
    def dataReceived(self, data: Any) -> None: ...
    disconnecting: int = ...
    def loseConnection(self) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...

class _BaseProcess(BaseProcess):
    status: Optional[int] = ...
    pid: Any = ...
    def reapProcess(self) -> None: ...
    def signalProcess(self, signalID: Any) -> None: ...

class _FDDetector:
    listdir: Any = ...
    getpid: Any = ...
    openfile: Any = ...
    def __init__(self) -> None: ...

detector: Any

class Process(_BaseProcess):
    debug: bool = ...
    debug_child: bool = ...
    status: int = ...
    pid: Any = ...
    processWriterFactory: Any = ...
    processReaderFactory: Any = ...
    pipes: Any = ...
    proto: Any = ...
    def __init__(self, reactor: Any, executable: Any, args: Any, environment: Any, path: Any, proto: Any, uid: Optional[Any] = ..., gid: Optional[Any] = ..., childFDs: Optional[Any] = ...): ...
    def writeToChild(self, childFD: Any, data: Any) -> None: ...
    def closeChildFD(self, childFD: Any) -> None: ...
    def pauseProducing(self) -> None: ...
    def resumeProducing(self) -> None: ...
    def closeStdin(self) -> None: ...
    def closeStdout(self) -> None: ...
    def closeStderr(self) -> None: ...
    def loseConnection(self) -> None: ...
    def write(self, data: Any) -> None: ...
    def registerProducer(self, producer: Any, streaming: Any) -> None: ...
    def unregisterProducer(self) -> None: ...
    def writeSequence(self, seq: Any) -> None: ...
    def childDataReceived(self, name: Any, data: Any) -> None: ...
    def childConnectionLost(self, childFD: Any, reason: Any) -> None: ...
    def maybeCallProcessEnded(self) -> None: ...
    def getHost(self) -> None: ...
    def getPeer(self) -> None: ...

class PTYProcess(abstract.FileDescriptor, _BaseProcess):
    status: int = ...
    pid: Any = ...
    fd: Any = ...
    connected: int = ...
    def __init__(self, reactor: Any, executable: Any, args: Any, environment: Any, path: Any, proto: Any, uid: Optional[Any] = ..., gid: Optional[Any] = ..., usePTY: Optional[Any] = ...) -> None: ...
    def closeStdin(self) -> None: ...
    def closeStdout(self) -> None: ...
    def closeStderr(self) -> None: ...
    def doRead(self): ...
    def fileno(self): ...
    def maybeCallProcessEnded(self) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...
    def writeSomeData(self, data: Any): ...
    def closeChildFD(self, descriptor: Any) -> None: ...
    def writeToChild(self, childFD: Any, data: Any) -> None: ...
