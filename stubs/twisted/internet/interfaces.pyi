from socket import AddressFamily
from twisted.internet.abstract import FileDescriptor as FileDescriptor
from twisted.internet.address import IPv4Address as IPv4Address, IPv6Address as IPv6Address, UNIXAddress as UNIXAddress
from twisted.internet.defer import Deferred as Deferred
from twisted.internet.protocol import ClientFactory as ClientFactory, ConnectedDatagramProtocol as ConnectedDatagramProtocol, DatagramProtocol as DatagramProtocol, Factory as Factory, ServerFactory as ServerFactory
from twisted.internet.ssl import ClientContextFactory as ClientContextFactory
from twisted.names.dns import Query as Query
from twisted.protocols.tls import TLSMemoryBIOProtocol as TLSMemoryBIOProtocol
from twisted.python.failure import Failure as Failure
from twisted.python.runtime import platform as platform
from twisted.python.threadpool import ThreadPool as ThreadPool
from typing import Any, AnyStr, Callable, Iterable, List, Mapping, Optional, Sequence, Tuple, Union
from zope.interface import Interface

OpenSSLConnection = object
OpenSSLContext = object
ThreadPool = object

class IAddress(Interface): ...

class IConnector(Interface):
    def stopConnecting() -> None: ...
    def disconnect() -> None: ...
    def connect() -> None: ...
    def getDestination() -> IAddress: ...

class IResolverSimple(Interface):
    def getHostByName(name: str, timeout: Sequence[int]) -> Deferred: ...

class IHostResolution(Interface):
    name: Any = ...
    def cancel() -> None: ...

class IResolutionReceiver(Interface):
    def resolutionBegan(resolutionInProgress: IHostResolution) -> None: ...
    def addressResolved(address: IAddress) -> None: ...
    def resolutionComplete() -> None: ...

class IHostnameResolver(Interface):
    def resolveHostName(resolutionReceiver: IResolutionReceiver, hostName: str, portNumber: int, addressTypes: Sequence[IAddress], transportSemantics: str) -> IResolutionReceiver: ...

class IResolver(IResolverSimple):
    def query(query: Query, timeout: Sequence[int]) -> Deferred: ...
    def lookupAddress(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupAddress6(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupIPV6Address(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupMailExchange(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupNameservers(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupCanonicalName(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupMailBox(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupMailGroup(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupMailRename(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupPointer(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupAuthority(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupNull(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupWellKnownServices(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupHostInfo(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupMailboxInfo(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupText(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupResponsibility(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupAFSDatabase(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupService(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupAllRecords(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupSenderPolicy(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupNamingAuthorityPointer(name: str, timeout: Sequence[int]) -> Deferred: ...
    def lookupZone(name: str, timeout: Sequence[int]) -> Deferred: ...

class IReactorTCP(Interface):
    def listenTCP(port: int, factory: ServerFactory, backlog: int, interface: str) -> IListeningPort: ...
    def connectTCP(host: bytes, port: int, factory: ClientFactory, timeout: float, bindAddress: Optional[Tuple[str, int]]) -> IConnector: ...

class IReactorSSL(Interface):
    def connectSSL(host: str, port: int, factory: ClientFactory, contextFactory: ClientContextFactory, timeout: float, bindAddress: Optional[Tuple[str, int]]) -> IConnector: ...
    def listenSSL(port: int, factory: ServerFactory, contextFactory: IOpenSSLContextFactory, backlog: int, interface: str) -> int: ...

class IReactorUNIX(Interface):
    def connectUNIX(address: str, factory: ClientFactory, timeout: float, checkPID: bool) -> IConnector: ...
    def listenUNIX(address: str, factory: Factory, backlog: int, mode: int, wantPID: bool) -> IListeningPort: ...

class IReactorUNIXDatagram(Interface):
    def connectUNIXDatagram(address: str, protocol: ConnectedDatagramProtocol, maxPacketSize: int, mode: int, bindAddress: Optional[Tuple[str, int]]) -> IConnector: ...
    def listenUNIXDatagram(address: str, protocol: DatagramProtocol, maxPacketSize: int, mode: int) -> IListeningPort: ...

class IReactorWin32Events(Interface):
    def addEvent(event: object, fd: FileDescriptor, action: str) -> None: ...
    def removeEvent(event: object) -> None: ...

class IReactorUDP(Interface):
    def listenUDP(port: int, protocol: DatagramProtocol, interface: str, maxPacketSize: int) -> IListeningPort: ...

class IReactorMulticast(Interface):
    def listenMulticast(port: int, protocol: DatagramProtocol, interface: str, maxPacketSize: int, listenMultiple: bool) -> IListeningPort: ...

class IReactorSocket(Interface):
    def adoptStreamPort(fileDescriptor: int, addressFamily: AddressFamily, factory: ServerFactory) -> IListeningPort: ...
    def adoptStreamConnection(fileDescriptor: int, addressFamily: AddressFamily, factory: ServerFactory) -> None: ...
    def adoptDatagramPort(fileDescriptor: int, addressFamily: AddressFamily, protocol: DatagramProtocol, maxPacketSize: int) -> IListeningPort: ...

class IReactorProcess(Interface):
    def spawnProcess(processProtocol: IProcessProtocol, executable: Union[bytes, str], args: Sequence[Union[bytes, str]], env: Optional[Mapping[AnyStr, AnyStr]], path: Union[bytes, str], uid: int, gid: int, usePTY: bool, childFDs: Mapping[int, Union[int, str]]) -> IProcessTransport: ...

class IReactorTime(Interface):
    def seconds() -> float: ...
    def callLater(delay: float, callable: Callable[..., Any], *args: object, **kwargs: object) -> IDelayedCall: ...
    def getDelayedCalls() -> List[IDelayedCall]: ...

class IDelayedCall(Interface):
    def getTime() -> float: ...
    def cancel() -> None: ...
    def delay(secondsLater: float) -> None: ...
    def reset(secondsFromNow: float) -> None: ...
    def active() -> bool: ...

class IReactorFromThreads(Interface):
    def callFromThread(callable: Callable[..., Any], *args: object, **kwargs: object) -> None: ...

class IReactorInThreads(Interface):
    def callInThread(callable: Callable[..., Any], *args: object, **kwargs: object) -> None: ...

class IReactorThreads(IReactorFromThreads, IReactorInThreads):
    def getThreadPool() -> ThreadPool: ...
    def suggestThreadPoolSize(size: int) -> None: ...

class IReactorCore(Interface):
    running: Any = ...
    def resolve(name: str, timeout: Sequence[int]) -> Deferred: ...
    def run() -> None: ...
    def stop() -> None: ...
    def crash() -> None: ...
    def iterate(delay: float) -> None: ...
    def fireSystemEvent(eventType: str) -> None: ...
    def addSystemEventTrigger(phase: str, eventType: str, callable: Callable[..., Any], *args: object, **kwargs: object) -> Any: ...
    def removeSystemEventTrigger(triggerID: Any) -> None: ...
    def callWhenRunning(callable: Callable[..., Any], *args: object, **kwargs: object) -> Optional[Any]: ...

class IReactorPluggableResolver(Interface):
    def installResolver(resolver: IResolverSimple) -> IResolverSimple: ...

class IReactorPluggableNameResolver(Interface):
    nameResolver: Any = ...
    def installNameResolver(resolver: IHostnameResolver) -> IHostnameResolver: ...

class IReactorDaemonize(Interface):
    def beforeDaemonize() -> None: ...
    def afterDaemonize() -> None: ...

class IReactorFDSet(Interface):
    def addReader(reader: IReadDescriptor) -> None: ...
    def addWriter(writer: IWriteDescriptor) -> None: ...
    def removeReader(reader: IReadDescriptor) -> None: ...
    def removeWriter(writer: IWriteDescriptor) -> None: ...
    def removeAll() -> List[Union[IReadDescriptor, IWriteDescriptor]]: ...
    def getReaders() -> List[IReadDescriptor]: ...
    def getWriters() -> List[IWriteDescriptor]: ...

class IListeningPort(Interface):
    def startListening() -> None: ...
    def stopListening() -> None: ...
    def getHost() -> IAddress: ...

class ILoggingContext(Interface):
    def logPrefix() -> str: ...

class IFileDescriptor(ILoggingContext):
    def fileno() -> object: ...
    def connectionLost(reason: Failure) -> None: ...

class IReadDescriptor(IFileDescriptor):
    def doRead() -> Optional[Failure]: ...

class IWriteDescriptor(IFileDescriptor):
    def doWrite() -> Optional[Failure]: ...

class IReadWriteDescriptor(IReadDescriptor, IWriteDescriptor): ...

class IHalfCloseableDescriptor(Interface):
    def writeConnectionLost(reason: Failure) -> None: ...
    def readConnectionLost(reason: Failure) -> None: ...

class ISystemHandle(Interface):
    def getHandle() -> object: ...

class IConsumer(Interface):
    def registerProducer(producer: IProducer, streaming: bool) -> None: ...
    def unregisterProducer() -> None: ...
    def write(data: bytes) -> None: ...

class IProducer(Interface):
    def stopProducing() -> None: ...

class IPushProducer(IProducer):
    def pauseProducing() -> None: ...
    def resumeProducing() -> None: ...

class IPullProducer(IProducer):
    def resumeProducing() -> None: ...

class IProtocol(Interface):
    def dataReceived(data: bytes) -> None: ...
    def connectionLost(reason: Failure) -> None: ...
    def makeConnection(transport: ITransport) -> None: ...
    def connectionMade() -> None: ...

class IProcessProtocol(Interface):
    def makeConnection(process: IProcessTransport) -> None: ...
    def childDataReceived(childFD: int, data: bytes) -> None: ...
    def childConnectionLost(childFD: int) -> None: ...
    def processExited(reason: Failure) -> None: ...
    def processEnded(reason: Failure) -> None: ...

class IHalfCloseableProtocol(Interface):
    def readConnectionLost() -> None: ...
    def writeConnectionLost() -> None: ...

class IHandshakeListener(Interface):
    def handshakeCompleted() -> None: ...

class IFileDescriptorReceiver(Interface):
    def fileDescriptorReceived(descriptor: int) -> None: ...

class IProtocolFactory(Interface):
    def buildProtocol(addr: Tuple[str, int]) -> Optional[IProtocol]: ...
    def doStart() -> None: ...
    def doStop() -> None: ...

class ITransport(Interface):
    def write(data: bytes) -> None: ...
    def writeSequence(data: Iterable[bytes]) -> None: ...
    def loseConnection() -> None: ...
    def getPeer() -> IAddress: ...
    def getHost() -> IAddress: ...

class ITCPTransport(ITransport):
    def loseWriteConnection() -> None: ...
    def abortConnection() -> None: ...
    def getTcpNoDelay() -> bool: ...
    def setTcpNoDelay(enabled: bool) -> None: ...
    def getTcpKeepAlive() -> bool: ...
    def setTcpKeepAlive(enabled: bool) -> None: ...
    def getHost() -> Union[IPv4Address, IPv6Address]: ...
    def getPeer() -> Union[IPv4Address, IPv6Address]: ...

class IUNIXTransport(ITransport):
    def sendFileDescriptor(descriptor: int) -> None: ...

class IOpenSSLServerConnectionCreator(Interface):
    def serverConnectionForTLS(tlsProtocol: TLSMemoryBIOProtocol) -> OpenSSLConnection: ...

class IOpenSSLClientConnectionCreator(Interface):
    def clientConnectionForTLS(tlsProtocol: TLSMemoryBIOProtocol) -> OpenSSLConnection: ...

class IProtocolNegotiationFactory(Interface):
    def acceptableProtocols() -> List[bytes]: ...

class IOpenSSLContextFactory(Interface):
    def getContext() -> OpenSSLContext: ...

class ITLSTransport(ITCPTransport):
    def startTLS(contextFactory: Union[IOpenSSLClientConnectionCreator, IOpenSSLServerConnectionCreator]) -> None: ...

class ISSLTransport(ITCPTransport):
    def getPeerCertificate() -> object: ...

class INegotiated(ISSLTransport):
    negotiatedProtocol: Any = ...

class ICipher(Interface):
    fullName: Any = ...

class IAcceptableCiphers(Interface):
    def selectCiphers(availableCiphers: Tuple[ICipher]) -> Tuple[ICipher]: ...

class IProcessTransport(ITransport):
    pid: Any = ...
    def closeStdin() -> None: ...
    def closeStdout() -> None: ...
    def closeStderr() -> None: ...
    def closeChildFD(descriptor: int) -> None: ...
    def writeToChild(childFD: int, data: bytes) -> None: ...
    def loseConnection() -> None: ...
    def signalProcess(signalID: Union[str, int]) -> None: ...

class IServiceCollection(Interface):
    def getServiceNamed(serviceName: str) -> object: ...
    def addService(service: object) -> None: ...
    def removeService(service: object) -> None: ...

class IUDPTransport(Interface):
    def write(packet: bytes, addr: Optional[Tuple[str, int]]) -> None: ...
    def connect(host: str, port: int) -> None: ...
    def getHost() -> Union[IPv4Address, IPv6Address]: ...
    def stopListening() -> None: ...
    def setBroadcastAllowed(enabled: bool) -> None: ...
    def getBroadcastAllowed() -> bool: ...

class IUNIXDatagramTransport(Interface):
    def write(packet: bytes, addr: str) -> None: ...
    def getHost() -> UNIXAddress: ...

class IUNIXDatagramConnectedTransport(Interface):
    def write(packet: bytes) -> None: ...
    def getHost() -> UNIXAddress: ...
    def getPeer() -> UNIXAddress: ...

class IMulticastTransport(Interface):
    def getOutgoingInterface() -> str: ...
    def setOutgoingInterface(addr: str) -> None: ...
    def getLoopbackMode() -> bool: ...
    def setLoopbackMode(mode: bool) -> None: ...
    def getTTL() -> int: ...
    def setTTL(ttl: int) -> None: ...
    def joinGroup(addr: str, interface: str) -> Deferred: ...
    def leaveGroup(addr: str, interface: str) -> Deferred: ...

class IStreamClientEndpoint(Interface):
    def connect(protocolFactory: IProtocolFactory) -> Deferred: ...

class IStreamServerEndpoint(Interface):
    def listen(protocolFactory: IProtocolFactory) -> Deferred: ...

class IStreamServerEndpointStringParser(Interface):
    prefix: Any = ...
    def parseStreamServer(reactor: IReactorCore, *args: object, **kwargs: object) -> IStreamServerEndpoint: ...

class IStreamClientEndpointStringParserWithReactor(Interface):
    prefix: Any = ...
    def parseStreamClient(reactor: IReactorCore, *args: object, **kwargs: object) -> IStreamClientEndpoint: ...

class _ISupportsExitSignalCapturing(Interface): ...
