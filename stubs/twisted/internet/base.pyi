import abc
import socket
from abc import ABC
from twisted.internet import abstract as abstract, defer as defer, error as error, fdesc as fdesc, main as main, threads as threads
from twisted.internet.defer import Deferred as Deferred, DeferredList as DeferredList
from twisted.internet.interfaces import IAddress as IAddress, IConnector as IConnector, IDelayedCall as IDelayedCall, IHostnameResolver as IHostnameResolver, IProtocol as IProtocol, IReactorCore as IReactorCore, IReactorPluggableNameResolver as IReactorPluggableNameResolver, IReactorPluggableResolver as IReactorPluggableResolver, IReactorThreads as IReactorThreads, IReactorTime as IReactorTime, IReadDescriptor as IReadDescriptor, IResolverSimple as IResolverSimple, IWriteDescriptor as IWriteDescriptor
from twisted.internet.protocol import ClientFactory as ClientFactory
from twisted.internet.tcp import Client as Client
from twisted.python import log as log, reflect as reflect, threadable as threadable
from twisted.python.failure import Failure as Failure
from twisted.python.runtime import platform as platform
from twisted.python.threadpool import ThreadPool as ThreadPool
from types import FrameType
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union

class DelayedCall:
    debug: bool = ...
    resetter: Any = ...
    canceller: Any = ...
    seconds: Any = ...
    cancelled: int = ...
    delayed_time: float = ...
    creator: Any = ...
    def __init__(self, time: float, func: Callable[..., Any], args: Sequence[object], kw: Dict[str, object], cancel: Callable[[DelayedCall], None], reset: Callable[[DelayedCall], None], seconds: Callable[[], float]=...) -> None: ...
    def getTime(self) -> float: ...
    def cancel(self) -> None: ...
    time: Any = ...
    def reset(self, secondsFromNow: float) -> None: ...
    def delay(self, secondsLater: float) -> None: ...
    def activate_delay(self) -> None: ...
    def active(self) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...

class ThreadedResolver:
    reactor: Any = ...
    def __init__(self, reactor: ReactorBase) -> None: ...
    def getHostByName(self, name: str, timeout: Sequence[int]=...) -> Deferred: ...

class BlockingResolver:
    def getHostByName(self, name: str, timeout: Sequence[int]=...) -> Deferred: ...

class _ThreePhaseEvent:
    before: Any = ...
    during: Any = ...
    after: Any = ...
    state: str = ...
    def __init__(self) -> None: ...
    def addTrigger(self, phase: str, callable: _ThreePhaseEventTriggerCallable, *args: object, **kwargs: object) -> _ThreePhaseEventTriggerHandle: ...
    def removeTrigger(self, handle: _ThreePhaseEventTriggerHandle) -> None: ...
    def removeTrigger_BASE(self, handle: _ThreePhaseEventTriggerHandle) -> None: ...
    def removeTrigger_BEFORE(self, handle: _ThreePhaseEventTriggerHandle) -> None: ...
    finishedBefore: Any = ...
    def fireEvent(self) -> None: ...

class PluggableResolverMixin:
    resolver: IResolverSimple = ...
    def installResolver(self, resolver: IResolverSimple) -> IResolverSimple: ...
    def installNameResolver(self, resolver: IHostnameResolver) -> IHostnameResolver: ...
    @property
    def nameResolver(self) -> IHostnameResolver: ...

class ReactorBase(PluggableResolverMixin):
    installed: bool = ...
    usingThreads: bool = ...
    __name__: str = ...
    threadCallQueue: Any = ...
    running: bool = ...
    waker: Any = ...
    def __init__(self) -> None: ...
    def installWaker(self) -> None: ...
    def wakeUp(self) -> None: ...
    def doIteration(self, delay: Optional[float]) -> None: ...
    def addReader(self, reader: IReadDescriptor) -> None: ...
    def addWriter(self, writer: IWriteDescriptor) -> None: ...
    def removeReader(self, reader: IReadDescriptor) -> None: ...
    def removeWriter(self, writer: IWriteDescriptor) -> None: ...
    def removeAll(self) -> List[Union[IReadDescriptor, IWriteDescriptor]]: ...
    def getReaders(self) -> List[IReadDescriptor]: ...
    def getWriters(self) -> List[IWriteDescriptor]: ...
    def resolve(self, name: str, timeout: Sequence[int]=...) -> Deferred: ...
    def stop(self) -> None: ...
    def crash(self) -> None: ...
    def sigInt(self, number: int, frame: Optional[FrameType]=...) -> None: ...
    def sigBreak(self, number: int, frame: Optional[FrameType]=...) -> None: ...
    def sigTerm(self, number: int, frame: Optional[FrameType]=...) -> None: ...
    def disconnectAll(self) -> None: ...
    def iterate(self, delay: float=...) -> None: ...
    def fireSystemEvent(self, eventType: str) -> None: ...
    def addSystemEventTrigger(self, phase: str, eventType: str, callable: Callable[..., Any], *args: object, **kwargs: object) -> _SystemEventID: ...
    def removeSystemEventTrigger(self, triggerID: _SystemEventID) -> None: ...
    def callWhenRunning(self, callable: Callable[..., Any], *args: object, **kwargs: object) -> Optional[_SystemEventID]: ...
    def startRunning(self) -> None: ...
    def run(self) -> None: ...
    seconds: Any = ...
    def callLater(self, delay: float, callable: Callable[..., Any], *args: object, **kw: object) -> DelayedCall: ...
    def getDelayedCalls(self) -> List[IDelayedCall]: ...
    def timeout(self) -> Optional[float]: ...
    def runUntilCurrent(self) -> None: ...
    threadpool: Any = ...
    threadpoolShutdownID: Any = ...
    def callFromThread(self, f: Callable[..., Any], *args: object, **kwargs: object) -> None: ...
    def getThreadPool(self) -> ThreadPool: ...
    def callInThread(self, _callable: Callable[..., Any], *args: object, **kwargs: object) -> None: ...
    def suggestThreadPoolSize(self, size: int) -> None: ...
    def callFromThread(self, f: Callable[..., Any], *args: object, **kwargs: object) -> None: ...

class BaseConnector(ABC, metaclass=abc.ABCMeta):
    timeoutID: Any = ...
    factoryStarted: int = ...
    state: str = ...
    reactor: Any = ...
    factory: Any = ...
    timeout: Any = ...
    def __init__(self, factory: ClientFactory, timeout: float, reactor: ReactorBase) -> None: ...
    def disconnect(self) -> None: ...
    transport: Any = ...
    def connect(self) -> None: ...
    def stopConnecting(self) -> None: ...
    def cancelTimeout(self) -> None: ...
    def buildProtocol(self, addr: Tuple[str, int]) -> IProtocol: ...
    def connectionFailed(self, reason: Failure) -> None: ...
    def connectionLost(self, reason: Failure) -> None: ...
    def getDestination(self) -> IAddress: ...

class BasePort(abstract.FileDescriptor):
    addressFamily: socket.AddressFamily = ...
    socketType: socket.SocketKind = ...
    def createInternetSocket(self) -> socket.socket: ...
    def doWrite(self) -> Optional[Failure]: ...

class _SignalReactorMixin:
    def startRunning(self, installSignalHandlers: bool=...) -> None: ...
    def run(self, installSignalHandlers: bool=...) -> None: ...
    def mainLoop(self) -> None: ...
