from twisted.internet import protocol
from twisted.names.error import AuthoritativeDomainError as AuthoritativeDomainError, DNSQueryTimeoutError as DNSQueryTimeoutError, DomainError as DomainError
from twisted.python import util as tputil
from typing import Any, Optional, SupportsInt, Union
from zope.interface import Interface

PORT: int
A: Any
NS: Any
MD: Any
MF: Any
CNAME: Any
SOA: Any
MB: Any
MG: Any
MR: Any
NULL: Any
WKS: Any
PTR: Any
HINFO: Any
MINFO: Any
MX: Any
TXT: Any
RP: Any
AFSDB: Any
AAAA: int
SRV: int
NAPTR: int
A6: int
DNAME: int
OPT: int
SSHFP: int
SPF: int
TSIG: int
QUERY_TYPES: Any
IXFR: Any
AXFR: Any
MAILB: Any
MAILA: Any
ALL_RECORDS: Any
EXT_QUERIES: Any
REV_TYPES: Any
IN: Any
CS: Any
CH: Any
HS: Any
ANY: int
QUERY_CLASSES: Any
REV_CLASSES: Any
OP_QUERY: Any
OP_INVERSE: Any
OP_STATUS: Any
OP_NOTIFY: int
OP_UPDATE: int
OK: Any
EFORMAT: Any
ESERVER: Any
ENAME: Any
ENOTIMP: Any
EREFUSED: Any
EBADVERSION: int
EBADSIG: Any
EBADKEY: Any
EBADTIME: Any

class IRecord(Interface):
    TYPE: Any = ...

class IEncodable(Interface):
    def encode(strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(strio: Any, length: Optional[Any] = ...) -> None: ...

class IEncodableRecord(IEncodable, IRecord): ...

class Charstr:
    string: Any = ...
    def __init__(self, string: bytes = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> Any: ...

class Name:
    name: Any = ...
    def __init__(self, name: bytes = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> Any: ...

class Query:
    name: Any = ...
    type: Any = ...
    cls: Any = ...
    def __init__(self, name: Union[bytes, str]=..., type: int=..., cls: int=...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def __cmp__(self, other: Any): ...

class _OPTHeader(tputil.FancyStrMixin, tputil.FancyEqMixin):
    showAttributes: Any = ...
    compareAttributes: Any = ...
    udpPayloadSize: Any = ...
    extendedRCODE: Any = ...
    version: Any = ...
    dnssecOK: Any = ...
    options: Any = ...
    def __init__(self, udpPayloadSize: int = ..., extendedRCODE: int = ..., version: int = ..., dnssecOK: bool = ..., options: Optional[Any] = ...) -> None: ...
    @property
    def name(self): ...
    @property
    def type(self): ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    @classmethod
    def fromRRHeader(cls, rrHeader: Any): ...

class _OPTVariableOption(tputil.FancyStrMixin, tputil.FancyEqMixin):
    showAttributes: Any = ...
    compareAttributes: Any = ...
    code: Any = ...
    data: Any = ...
    def __init__(self, code: int = ..., data: bytes = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...

class RRHeader(tputil.FancyEqMixin):
    compareAttributes: Any = ...
    fmt: str = ...
    rdlength: Any = ...
    cachedResponse: Any = ...
    name: Any = ...
    type: Any = ...
    cls: Any = ...
    ttl: Any = ...
    payload: Any = ...
    auth: Any = ...
    def __init__(self, name: Union[bytes, str]=..., type: int=..., cls: int=..., ttl: SupportsInt=..., payload: Optional[IEncodableRecord]=..., auth: bool=...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def isAuthoritative(self): ...

class SimpleRecord(tputil.FancyStrMixin, tputil.FancyEqMixin):
    showAttributes: Any = ...
    compareAttributes: Any = ...
    TYPE: Optional[int] = ...
    name: Any = ...
    ttl: Any = ...
    def __init__(self, name: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_NS(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_MD(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_MF(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_CNAME(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_MB(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_MG(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_MR(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_PTR(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_DNAME(SimpleRecord):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_A(tputil.FancyEqMixin):
    compareAttributes: Any = ...
    TYPE: Any = ...
    address: Any = ...
    ttl: Any = ...
    def __init__(self, address: str = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def dottedQuad(self): ...

class Record_SOA(tputil.FancyEqMixin, tputil.FancyStrMixin):
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    TYPE: Any = ...
    retry: Any = ...
    ttl: Any = ...
    def __init__(self, mname: bytes = ..., rname: bytes = ..., serial: int = ..., refresh: int = ..., retry: int = ..., expire: int = ..., minimum: int = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_NULL(tputil.FancyStrMixin, tputil.FancyEqMixin):
    fancybasename: str = ...
    showAttributes: Any = ...
    compareAttributes: Any = ...
    TYPE: Any = ...
    payload: Any = ...
    ttl: Any = ...
    def __init__(self, payload: Optional[Any] = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_WKS(tputil.FancyEqMixin, tputil.FancyStrMixin):
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    TYPE: Any = ...
    address: Any = ...
    ttl: Any = ...
    def __init__(self, address: str = ..., protocol: int = ..., map: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    protocol: Any = ...
    map: Any = ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_AAAA(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    showAttributes: Any = ...
    compareAttributes: Any = ...
    address: Any = ...
    ttl: Any = ...
    def __init__(self, address: str = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_A6(tputil.FancyStrMixin, tputil.FancyEqMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    showAttributes: Any = ...
    compareAttributes: Any = ...
    prefixLen: Any = ...
    suffix: Any = ...
    prefix: Any = ...
    bytes: Any = ...
    ttl: Any = ...
    def __init__(self, prefixLen: int = ..., suffix: str = ..., prefix: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> Any: ...

class Record_SRV(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    priority: Any = ...
    weight: Any = ...
    port: Any = ...
    target: Any = ...
    ttl: Any = ...
    def __init__(self, priority: int = ..., weight: int = ..., port: int = ..., target: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_NAPTR(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    compareAttributes: Any = ...
    fancybasename: str = ...
    showAttributes: Any = ...
    order: Any = ...
    preference: Any = ...
    flags: Any = ...
    service: Any = ...
    regexp: Any = ...
    replacement: Any = ...
    ttl: Any = ...
    def __init__(self, order: int = ..., preference: int = ..., flags: bytes = ..., service: bytes = ..., regexp: bytes = ..., replacement: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_AFSDB(tputil.FancyStrMixin, tputil.FancyEqMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    subtype: Any = ...
    hostname: Any = ...
    ttl: Any = ...
    def __init__(self, subtype: int = ..., hostname: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_RP(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    mbox: Any = ...
    txt: Any = ...
    ttl: Any = ...
    def __init__(self, mbox: bytes = ..., txt: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_HINFO(tputil.FancyStrMixin, tputil.FancyEqMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    showAttributes: Any = ...
    compareAttributes: Any = ...
    ttl: Any = ...
    def __init__(self, cpu: bytes = ..., os: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    cpu: Any = ...
    os: Any = ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> Any: ...

class Record_MINFO(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    rmailbx: Any = ...
    emailbx: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    ttl: Any = ...
    def __init__(self, rmailbx: bytes = ..., emailbx: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_MX(tputil.FancyStrMixin, tputil.FancyEqMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    preference: Any = ...
    name: Any = ...
    ttl: Any = ...
    def __init__(self, preference: int = ..., name: bytes = ..., ttl: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_SSHFP(tputil.FancyEqMixin, tputil.FancyStrMixin):
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    TYPE: Any = ...
    ALGORITHM_RSA: int = ...
    ALGORITHM_DSS: int = ...
    ALGORITHM_ECDSA: int = ...
    ALGORITHM_Ed25519: int = ...
    FINGERPRINT_TYPE_SHA1: int = ...
    FINGERPRINT_TYPE_SHA256: int = ...
    algorithm: Any = ...
    fingerprintType: Any = ...
    fingerprint: Any = ...
    ttl: Any = ...
    def __init__(self, algorithm: int = ..., fingerprintType: int = ..., fingerprint: bytes = ..., ttl: int = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_TXT(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    showAttributes: Any = ...
    compareAttributes: Any = ...
    data: Any = ...
    ttl: Any = ...
    def __init__(self, *data: Any, **kw: Any) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class UnknownRecord(tputil.FancyEqMixin, tputil.FancyStrMixin):
    TYPE: Any = ...
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    data: Any = ...
    ttl: Any = ...
    def __init__(self, data: bytes = ..., ttl: Optional[Any] = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Record_SPF(Record_TXT):
    TYPE: Any = ...
    fancybasename: str = ...

class Record_TSIG(tputil.FancyEqMixin, tputil.FancyStrMixin):
    fancybasename: str = ...
    compareAttributes: Any = ...
    showAttributes: Any = ...
    TYPE: Any = ...
    algorithm: Any = ...
    timeSigned: Any = ...
    fudge: Any = ...
    MAC: Any = ...
    originalID: Any = ...
    error: Any = ...
    otherData: Any = ...
    ttl: Any = ...
    def __init__(self, algorithm: Optional[Any] = ..., timeSigned: Optional[Any] = ..., fudge: int = ..., MAC: Optional[Any] = ..., originalID: int = ..., error: Any = ..., otherData: bytes = ..., ttl: int = ...) -> None: ...
    def encode(self, strio: Any, compDict: Optional[Any] = ...) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...

class Message(tputil.FancyEqMixin):
    compareAttributes: Any = ...
    headerFmt: str = ...
    headerSize: Any = ...
    queries: Any = ...
    answers: Any = ...
    add: Any = ...
    ns: Any = ...
    maxSize: Any = ...
    id: Any = ...
    answer: Any = ...
    opCode: Any = ...
    auth: Any = ...
    trunc: Any = ...
    recDes: Any = ...
    recAv: Any = ...
    rCode: Any = ...
    authenticData: Any = ...
    checkingDisabled: Any = ...
    authority: Any = ...
    additional: Any = ...
    def __init__(self, id: int = ..., answer: int = ..., opCode: int = ..., recDes: int = ..., recAv: int = ..., auth: int = ..., rCode: Any = ..., trunc: int = ..., maxSize: int = ..., authenticData: int = ..., checkingDisabled: int = ...) -> None: ...
    def addQuery(self, name: Any, type: Any = ..., cls: Any = ...) -> None: ...
    def encode(self, strio: Any) -> None: ...
    def decode(self, strio: Any, length: Optional[Any] = ...) -> None: ...
    def parseRecords(self, list: Any, num: Any, strio: Any) -> None: ...
    def lookupRecordType(self, type: Any): ...
    def toStr(self): ...
    def fromStr(self, str: Any) -> None: ...

class _EDNSMessage(tputil.FancyEqMixin):
    compareAttributes: Any = ...
    id: Any = ...
    answer: Any = ...
    opCode: Any = ...
    auth: Any = ...
    trunc: Any = ...
    recDes: Any = ...
    recAv: Any = ...
    rCode: Any = ...
    ednsVersion: Any = ...
    dnssecOK: Any = ...
    authenticData: Any = ...
    checkingDisabled: Any = ...
    maxSize: Any = ...
    queries: Any = ...
    answers: Any = ...
    authority: Any = ...
    additional: Any = ...
    def __init__(self, id: int = ..., answer: bool = ..., opCode: Any = ..., auth: bool = ..., trunc: bool = ..., recDes: bool = ..., recAv: bool = ..., rCode: int = ..., ednsVersion: int = ..., dnssecOK: bool = ..., authenticData: bool = ..., checkingDisabled: bool = ..., maxSize: int = ..., queries: Optional[Any] = ..., answers: Optional[Any] = ..., authority: Optional[Any] = ..., additional: Optional[Any] = ...) -> None: ...
    def toStr(self): ...
    def fromStr(self, bytes: Any) -> None: ...

class DNSMixin:
    id: Any = ...
    liveMessages: Any = ...
    controller: Any = ...
    def __init__(self, controller: Any, reactor: Optional[Any] = ...) -> None: ...
    def pickID(self): ...
    def callLater(self, period: Any, func: Any, *args: Any): ...

class DNSDatagramProtocol(DNSMixin, protocol.DatagramProtocol):
    resends: Any = ...
    liveMessages: Any = ...
    transport: Any = ...
    def stopProtocol(self) -> None: ...
    def startProtocol(self) -> None: ...
    def writeMessage(self, message: Any, address: Any) -> None: ...
    def startListening(self) -> None: ...
    def datagramReceived(self, data: Any, addr: Any) -> None: ...
    def removeResend(self, id: Any) -> None: ...
    def query(self, address: Any, queries: Any, timeout: int = ..., id: Optional[Any] = ...): ...

class DNSProtocol(DNSMixin, protocol.Protocol):
    length: Any = ...
    buffer: bytes = ...
    def writeMessage(self, message: Any) -> None: ...
    liveMessages: Any = ...
    def connectionMade(self) -> None: ...
    def connectionLost(self, reason: Any) -> None: ...
    def dataReceived(self, data: Any) -> None: ...
    def query(self, queries: Any, timeout: int = ...): ...
